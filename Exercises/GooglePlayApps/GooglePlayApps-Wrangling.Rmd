---
title: "Google Play Apps"
output: github_document
---


# Data Visualization of Google Play Apps

## Dataset Description

Dataset downloaded from: https://www.kaggle.com/lava18/google-play-store-apps

Loading the dataset

```{r warning=FALSE, message=FALSE}
library(tidyverse)
library(ggplot2)
library(lattice)
library(latticeExtra)
library(lubridate)
library(dslabs)

ds_theme_set()
apps_dataset_original = read.csv("../../data/googleplaystore.csv", header = TRUE, sep = ",")

#class(apps_dataset)
head(as.tibble(apps_dataset_original))


# apps_dataset_original %>% 
#   group_by(Installs) %>%
#   select(Installs, App) %>%
#   summarize(count = n())

```


## Data wrangling
Let's confirm the column types are correct and also the values.  


### App Feature

From previous point, we can see the App column, which contains app names, is factor data type, we need to change it to character.

```{r}
apps_dataset_original = read.csv("../../data/googleplaystore.csv", header = TRUE, sep = ",", as.is = c("App"))

head(as.tibble(apps_dataset_original))
```



#### Incorrect record

In a later analysis has been detected a broken record, but since this affects to the rest of conversions has been moved into this first steps.

```{r}
apps_dataset_original %>%
  filter(Category == "1.9") %>%
  head()  
```

So we can see the Category feature is missing, and the rest of the values are shift to the left, so we can fix it, and the best option is to do it from the begining. So we need to find the best category, based on the app name.

```{r}
apps_dataset_original %>% 
  filter(str_detect(App,"photo")) %>%
  select(Category) %>%
  head()
```

"PHOTOGRAPHY" category seems to be the most properly for this app
```{r}
col_number <- ncol(apps_dataset_original)
rows_indx <- apps_dataset_original[,1] == "Life Made WI-Fi Touchscreen Photo Frame"
apps_dataset_original[rows_indx,3:col_number]  <- apps_dataset_original[rows_indx,2:(col_number-1)]
apps_dataset_original[rows_indx,2] <- "PHOTOGRAPHY"

apps_dataset_original %>%
  filter(App == "Life Made WI-Fi Touchscreen Photo Frame") %>%
  head()  

  
```

Now Genres feature has NA,let's see if we can set any that makes sense

```{r}
apps_dataset_original %>% filter(Category == "PHOTOGRAPHY")%>% select(Genres) %>% distinct(Genres)
```

So for Category = "PHOTOGRAPHY" we must set Genres = "Photography"

```{r}
apps_dataset_original[rows_indx,10] <- "Photography"
apps_dataset_original[rows_indx,3] <- 1.9
apps_dataset_original %>%
  filter(App == "Life Made WI-Fi Touchscreen Photo Frame") %>%
  head()  
#levels(apps_dataset_original$Genres)

```



#### Duplicated Entries

It has been detected that the App name is duplicated for several apps, 
```{r}
duplicated_apps <- apps_dataset_original %>% 
  arrange(App) %>%
  group_by(App) %>% 
  filter(n() > 1) %>%
  ungroup()

duplicated_apps %>% select(App, Category, Rating, Current.Ver) %>% head()

```

**There are some cases where the app is more than once because it has a different version**

```{r}
duplicated_apps %>%
  distinct(App, Current.Ver) %>%
  group_by(App) %>%
  mutate(Current.Ver.Diff = n()) %>%
  ungroup() %>%
  filter(Current.Ver.Diff > 1) 
```

Since we are interested in the latest version only, we are going to get such record.


```{r}

apps_dataset_original %>%
  filter(str_detect(Current.Ver,","))

version.numbers <- c("3.27.3","2.3.3122","Varies with device","7","0.5")

get_max_app_version <- function(version.number){
  str_split(version.number,".")
  
}


```




In some cases we can see that the Category feature varies, for instance 8 Ball Pool

```{r}
duplicated_apps %>%
  select(App, Category) %>%
  group_by(App, Category) %>%
  summarize(n=n())

```

In other cases the Genre varies, these are the records that contain more than one Genre in different lines

```{r}

duplicated_apps %>%
  mutate(Genres = as.character(Genres)) %>%
  select(App, Genres) %>%
  distinct(App,Genres) %>%
  group_by(App) %>%
  summarize(n = n()) %>%
  filter(n > 1)

```

Let's see what they are...

```{r}
duplicated_apps %>%
  mutate(Genres = as.character(Genres)) %>%
  distinct(App,Genres) %>%
  group_by(App) %>%
  mutate(Genre.Duplicated = n()) %>%
  ungroup() %>%
  select(App, Genres, Genre.Duplicated) %>%
  filter(Genre.Duplicated > 1) 
```

There are also different number in ratings

```{r}

duplicated_apps %>%
  distinct(App, Rating) %>%
  group_by(App) %>%
  mutate(Rating.Diff= n()) %>%
  ungroup() %>%
  filter(Rating.Diff > 1)
  
  
class(duplicated_apps$Rating)

```






### Rating feature

Let's take a look at those features that contains NAs

```{r}
colnames(apps_dataset_original)[colSums(is.na(apps_dataset_original)) > 0]
```

Let's confirm how many observations there are with NA

We see Rating column is numeric
```{r}
class(apps_dataset_original$Rating)
```

Therefore those recods are missing, it may be due to:

    * They are new and therefore there are no yet any rating
    * There may be a new version with no ratings yet.
    * Missing value
    * It may be around for a while and it has no download (or almost none)
    

```{r}
apps_without_ratings <-  apps_dataset_original %>% 
  filter(is.na(Rating)) %>%
  nrow()

sprintf("There are %d without ratings", apps_without_ratings)
```

**So far we are going to keep the observations that no contains ratings**


Let's explore the Ratings... we are going to convert them in categorical data to see the values easily


```{r}
apps_dataset_original %>% 
  mutate(RatingTemp = round(Rating)) %>%
  filter(!is.na(RatingTemp)) %>%
  select(Rating, RatingTemp) %>%
  group_by(RatingTemp) %>%
  summarize()
```

We found that there are **Ratings of 19!!!** this is not expected

Let take a closer look

```{r}
apps_dataset_original %>%
  mutate(RatingTemp = round(Rating)) %>%
  group_by(RatingTemp) %>%
  summarize(count = n())
```

Validating if there are more Ratings out of range
```{r}
apps_dataset_original %>% 
  filter(Rating > 5.0 | Rating < 0) %>%
  count()
```


**There is only one app with Rating 19, it may be 1.9, I am taking the decision of changing the value to 1.9**

```{r}
apps_dataset <- apps_dataset_original
head(as.tibble(apps_dataset$Rating))

rating_indexes <- !is.na(apps_dataset[,3]) & apps_dataset[,3] > 5.0

apps_dataset[rating_indexes,3] <- apps_dataset[rating_indexes,3] * 0.1


```

Validating the change has been applied

```{r}
apps_dataset %>%
  mutate(RatingTemp = round(Rating)) %>%
  group_by(RatingTemp) %>%
  summarize(count = n())
```


```{r}
apps_dataset %>%
  ggplot(aes(x= Rating))+
  coord_cartesian(xlim = c(0,6)) +
  geom_histogram(bins=5) + 
  ggtitle("Rating distribution")
```


Taking a look at the proportion between those that don't have Ratings

```{r}
apps_dataset %>% 
  mutate(HasRating = !is.na(Rating)) %>%
  ggplot(aes(x ="", fill = HasRating)) +
  geom_bar() +
  coord_polar(theta = "y") +
  ggtitle("Proportion of Apps with Rating") +
  ylab("") +
  xlab("") +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
```


### Reviews Feature

We see this feature is set as factor when it must be numeric
```{r}
apps_dataset %>%
  filter(is.na(as.numeric(Reviews))) %>%
  select(App)
```
So, Reviews contains only numeric entries, so we convert those explicit

```{r}
apps_dataset <-  apps_dataset %>% 
  mutate(Reviews = as.numeric(Reviews))

head(as.tibble(apps_dataset))
```

The Reviews feature is now numeric, let's check if there are NAs

```{r}
na_counter <-sum(is.na(apps_dataset[,4]))
sprintf("There are %d Reviews with NA", na_counter)
```
So we are done with this feature.

```{r}
apps_dataset %>%
  group_by(Category) %>%
  summarize(count = n(), max = max(Reviews), min = min(Reviews))

```

```{r}
max_value <- max(apps_dataset$Reviews)
min_value <- min(apps_dataset$Reviews)
sprintf("Max value %d, Min value %d", max_value, min_value)
  
```

Let's take a quick view to the current data, sowe may see any unexpected value

```{r}
apps_dataset %>%
  ggplot(aes(x = Reviews, y = Reviews)) +
  geom_boxplot() +
  ggtitle("Review Distribution") +
  xlab("") +
  ylab("Number of Reviews") +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank()
  )
```



### Size Feature

This feature seems to be useful if we use it as numeric, anyway we need to remove the 'M' character, but we are not sure if there are other measurement units, such as GB, KB, etc.


```{r}
apps_dataset %>% 
  mutate(SizeNumeric = as.numeric(Size)) %>%
  filter(is.na(SizeNumeric)) %>% 
  select(Size, SizeNumeric) %>% head(n = 30)

```

**Interesting** the conversion does not fail, but the converted values are not the expected ones. so we are going to proceed to remove all non numeric characters, following this convention:

    * All values measure using M, will get rid of M, and converted
    * All values measure using k, will get rid of k, and converted into M scale
    * All values measure using +, will get rid of +, and as kept into M scale
    * 'Varies with device' will be set as NA
    

Those conventions were determined after some data exploration, you can see in the code below all we have remove

```{r}

pattern <- "(M[a-zA-Z]+)|([a-jl-zA-LN-Z])"

apps_dataset %>% filter(str_detect(Size, pattern = pattern) & Size != 'Varies with device') %>%
  select(App, Size) %>% 
  group_by(Size) %>%
  summary()
  
```

So We have detected that also k is added to the app size measurement, the observation is added to the previous list

#### Create new Size column with the numeric type only

```{r}
apps_dataset <- apps_dataset %>%
  mutate(SizeNumeric = case_when(
    !is.na(Size) & str_detect(Size,"M$") ~ as.numeric(str_replace(Size,"M$","")),
    !is.na(Size) & str_detect(Size,"k$") ~  round(as.numeric(str_replace(Size,"k$",""))/1024,3),
    Size == "Varies with device" ~ mean(NA),
    TRUE ~ as.numeric(NA)
  ))

```

We may consider to set the average size for those apps set as "Varies with device"... let's see what is the proportion.

```{r}
proportion_of_size <- sum(str_detect(apps_dataset$Size,"^Varies with device$"))/nrow(apps_dataset)
sprintf("Proportion of Size set as 'Varies with device': %f", proportion_of_size)
```

**This is the 15.6%, it is too high... I am going to fill out it with the mean according to its category** 

```{r}
size_summary <-  apps_dataset %>% 
  filter(!str_detect(Size, "^Varies with device$")) %>%
  group_by(Category) %>%
  select(Category, SizeNumeric) %>%
  summarize(Mean=round(mean(SizeNumeric),3))

apps_dataset <- apps_dataset %>%
  group_by(Category) %>%
  mutate(SizeNumeric = case_when(
    is.na(SizeNumeric) ~ mean(SizeNumeric[!is.na(SizeNumeric)]),
    TRUE ~ SizeNumeric)) %>%
  ungroup()
  
# Validating
apps_dataset %>%
  filter(str_detect(Size,"^Varies with device$")) %>%
  group_by(Category) %>%
  select(Category,Size, SizeNumeric) %>%
  head(n=10)
```

Now let's see the current data

```{r}
apps_dataset %>% 
  ggplot(aes(x = SizeNumeric, y = SizeNumeric)) +
  geom_boxplot() +
  ggtitle("Distribution of App Size") +
  xlab("") +
  ylab("App Size (MB)")
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank())
```

**At first sight all app sizes seem to be ok, it is expeted to have some few very big apps.**

### Install feature

We may need to keep it as factor, but we also will need it as numeric, so we are creating a second column with those values

We need to fix an incorrect value for Installs, it's "0" when it should be "0+", also two factors are not needed : "0" and "Free".
```{r}
apps_dataset %>% 
  group_by(Installs) %>%
  select(Installs, App) %>%
  summarize(count = n())

# Fixing invalid entry 0
apps_dataset$Installs[apps_dataset$Installs == "0"] <- "0+"

```



we need to remove: **",","+" **
    
```{r}

options(scipen = 999) # Disabling scientific notation
apps_dataset <- apps_dataset %>% 
  mutate(InstallsNumeric = str_replace_all(Installs, "[,*+$]", "")) %>%
  mutate(InstallsNumeric = as.integer(InstallsNumeric))

na_counter <- apps_dataset %>% 
    filter(is.na(InstallsNumeric)) %>%
    count()

sprintf("There are %d NAs", sum(na_counter))
summary(apps_dataset$InstallsNumeric)

```

There are no NA, it used to be due to the incorrect observation fixed at the beginning... But the current distribution is really odd

```{r}

apps_dataset %>% select(Installs,InstallsNumeric) %>% head()

apps_dataset %>%
  ggplot(aes(x=50, y = InstallsNumeric)) +
  geom_boxplot() +
  ggtitle("Install distribution") +
  xlab("") +
  ylab("Installations") +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank())
```


The outliers are really affecting our current box plot view...let remove those in order for usto be the main data.

```{r}
apps_dataset %>%
  filter(InstallsNumeric <=1000000) %>%
  ggplot(aes(x=50, y = InstallsNumeric)) +
  geom_boxplot() +
  ggtitle("Install distribution") +
  xlab("") +
  ylab("Installations") +
  theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank())
```

After taking a comparisson between Installations and InstallationNumeric columns, we can see the numbers are correct, and the distribution is really long. We will analyse later in depth

We also need to sort the levels to something that makes more sense to us.

```{r}
levels_sorted <- c("0+","1+","5+","10+","50+","100+","500+","1,000+","5,000+","10,000+","50,000+","100,000+","500,000+","1,000,000+","5,000,000+","10,000,000+","50,000,000+","100,000,000+","500,000,000+","1,000,000,000+","0","Free")

apps_dataset$Installs <- factor(apps_dataset$Installs,levels = levels_sorted)
```


### Price feature

The price feature is set as factor, we need to convert it to numeric

```{r}
apps_dataset %>%
  filter(is.na(as.numeric(Price))) %>%
  group_by(Type) %>%
  select(Type) %>%
  summary()

```
There are no NAs  

Let's validate there are no format characters

```{r}
apps_dataset %>%
  filter(str_detect(Price,pattern = "[a-zA-Z,$]")) %>%
  select(Price) %>%
  head()

```

There are format characters, so we need to clean up

```{r}
apps_dataset <- apps_dataset %>% 
  mutate(PriceNumeric = as.numeric(str_replace_all(Price,pattern = "[a-zA-Z,$]","")))
  

```

**Is there any Free application with Price different from 0?**

```{r}
apps_dataset %>%  filter(Type == 'Free' & Price != '0') %>% count()
```
**there is none**


**Is there any not free application but the price is 0?**

```{r}
apps_dataset %>%  filter(Type != 'Free' & Price == '0') %>% count()
```
**There is detected one incorrect Type observation, it was missing Free for price = 0**, so this is why the line below is there.


```{r}
apps_dataset %>%  filter(Type != 'Free' & Price == '0')
```

We didn't get any NA message when converting the Price column, but we are going to double check

```{r}
apps_dataset %>%
  filter(is.na(PriceNumeric)) %>%
  count()

```

Let's check what is the max and min prices (for min we are expecting 0)

```{r}
apps_dataset %>%  
  select(PriceNumeric) %>%
  summary(PriceNumeric) 
```

### Type feature

It has no specified the Type, so since the price is 0, we can assume the category is  Free

```{r}
apps_dataset %>%  filter(Type == 'NaN')

```

There is only one Type = "NaN", so we can fix it,since the Price = 0, we can set it Free.

```{r}
apps_dataset$Type[apps_dataset$Type == "NaN"] <- "Free"
apps_dataset %>%  filter(Type == 'NaN' | App == "Command & Conquer: Rivals")
```



### Last updated feature

We also need to set the dates in a valid format

Let's see if there are more than one format

```{r}
pattern = "[a-zA-Z]{3,9}\\s[0-9]{1,2},\\s[0-9]{4}"

match_counter <- apps_dataset %>% filter(str_detect(as.character(Last.Updated), pattern =  pattern)) %>% count()
sprintf("Matching %d of %d", sum(match_counter), nrow(apps_dataset))

```

So all dates seem to be in the same format, so we can convert.

```{r}

apps_dataset <- apps_dataset %>%
  mutate(Last.UpdatedDate = mdy(Last.Updated))

head(as.tibble(apps_dataset$Last.UpdatedDate))

```



##Content Rating feature

```{r}

apps_dataset %>%
  select (Content.Rating, App) %>%
  group_by(Content.Rating) %>%
  summary(count = count(App))

```

```{r}

apps_dataset$Content.Rating <-factor(apps_dataset$Content.Rating,levels=  c("Everyone","Everyone 10+","Teen","Mature 17+","Adults only 18+","Unrated"))

apps_dataset %>%
  select (Content.Rating, App) %>%
  group_by(Content.Rating) %>%
  summary(count = count(App))

```



## Genres feature

One app can have more than one genre, and the genres are recorded in the same value split by comas, so we need to extract all of them and create the relationship.

**Note: It has been validated that the max number of Genres per apps is 2**

```{r}
genres_dataset <- apps_dataset %>%
  mutate (Genres = as.character(Genres)) %>%
  select(App, Genres)
  

genres_dataset <- genres_dataset %>%  
  mutate(Test = str_split(genres_dataset$Genres, ";", simplify = TRUE))

apps_dataset_original %>%
  filter(App %in% c('Coloring book moana'))

apps_dataset %>% 
  select(App, Category) %>%
  group_by(App) %>% 
  count() %>%
  filter(n > 1) 

apps_dataset_original %>% 
  filter(App == "8 Ball Pool")


genres_dataset %>%  
  separate( Genres, c("Genre1","Genre2"),";") %>%
  gather("Genre", Genres,  `Genre1`:`Genre2`) %>% 
  filter(App %in% c('Coloring book moana')) %>%
  head()
#'Photo Editor & Candy Camera & Grid & ScrapBook',
```




## Record Counting

How many apps are there?

```{r}
rows_total <- nrow(apps_dataset)
rows_without_na <- nrow(na.omit(apps_dataset))

sprintf("Total apps %d", rows_total)
sprintf("Total apps %d, removing na", rows_without_na)
```



## Saving data locally to avoid continue processing it

```{r}
save(apps_dataset, file = "rda/apps_dataset.rda")
```
